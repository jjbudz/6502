#ifndef _L6502_H_
#define _L6502_H_
/**
 * @mainpage 6502
 * @section copyright_sec Copyright and License
 *
 * Copyright (c) 1998-2011 Jeff Budzinski
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * @section intro_sec Introduction
 *
 * blah blah blah
 *
 * @section quickstart_sec Quick Start
 *
 * blah blah blah
 *
 * @section assembler_sec The Assembler
 *
 * blah blah blah
 *
 * @section debugger_sec The Debugger
 *
 * blah blah blah
 *
 * @section command_sec Command Line Reference
 * 
 * blah blah blah
 *
 * @section todo_sec To Do List
 * @todo support more refined assembler syntax, see http://www.obelisk.demon.co.uk/6502/addressing.html
 * @todo unit tests for instructions (separate file and set of test programs)
 * @todo fix the assembler hacks for branching/jumps by adding instruction lengths to inst maps (see bytes struct member)
 * @todo assembler should understand addressing mode syntax
 * @todo need to add comments for instructions and what addressing modes they map to
 * @todo assembler should symbolic instruction names to the actual names for the addr mode in question
 * @todo implement zero page opcodes (?)
 * @todo add header comment block
 * @todo add external interfaces (load, save, assemble, run) and associated header
 * @todo create separate command line program main
 * @todo add assertions to ftrace to insure it does not assert at run time
 * @todo add register/address assertion functions/macros for use in unit tests
 * @todo establish clear function naming conventions (Uppercase external, lowercase internal?)
 * @todo fix doxygen comments
 * @todo provide automake build files for windows (32,64), linux (32,64), macos (32,64)
 * @todo document assembler syntax or create program option to dump opcode table and associate docs with each defined macro
 * @todo generate docs
 * @todo make it compatible with existing assembler source
 * @todo review function naming conventions for ext vs int use
 * @todo switch to native endian address/value storage (least)
 * @todo using short as an address is problematic because only 32k can be addressed
 * @todo would like to see the instruction set/assembler docs generated by doxy
 */

/**
 * Typedefs for key sized types
 */ 
typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;

/**
 * Addressable space using 16-bit addressing
 */
static const int k64K = 0x10000;

/**
 * Initializes the instruction table and corresponding functions
 * data structures, etc. Call before anything else.
 *
 * @return int 0 on success
 */
int initialize();

/**
 * Call to cleanup of data structures before program exit.
 *
 * @return int 0 on success
 */
int cleanup();

/**
 * Load an object file from the specified file.
 *
 * @param const char* name of an object file
 * @return int 0 on success; otherwise, error number
 */
int load(const char* filename);

/**
 * Save a program to the named file.
 *
 * @param const char* name of an object file
 * @return int 0 on success; otherwise, error number
 */
int save(const char* filename);

/*
 * Load the assembly program from the named file and attempt to
 * assemble it.
 *
 * @param const char* name of an object file
 * @return int 0 on success; otherwise, error number
 */
int assemble(const char* filename);

/**
 * Enter the interactive debugger using the object code at given address.
 */
int debug(uint16_t address);

/*
 * Print register values to stderr.
 */
void dumpRegisters();

/*
 * Print flags to stderr.
 */
void dumpFlags();

/*
 * Print stack values to stderr.
 */
void dumpStack();

/*
 * Print non-zero memory values to stderr.
 */
void dumpMemory(uint16_t first=0, uint16_t last=k64K-1);

/*
 * Print selected items to stderr.
 */
void dump(bool bRegisters=true, bool bFlags=true, bool bStack=true, bool bMemory=true);

/*
 * Turn object code into instruction descriptions (disassembly).
 */
void decodeAt(uint16_t address);

/**
 * Return the value of memory at the given address.
 */
uint8_t inspect(uint16_t address);

/**
 * Decode object code to symbolic instructions.
 */
void list(uint16_t first, uint16_t last);

/**
 * Interpret and execute a single instruction.
 */
int step();

/**
 * Run the object code found at the given address.
 */
int run(uint16_t address);

/**
 * Set a breakpoint at the specified address.
 */
void setBreak(uint16_t address);

/**
 * Remove a breakpoint.
 */
void clearBreak(uint16_t address);

/**
 * List all active breakpoints.
 */
void listBreak();

/**
 * Check the given address against active breakpoints.
 */
bool checkBreak(uint16_t address);

/**
 * Print version string and build timestamp
 */
void printVersion();

/*
 * Print the instruction table to stderr.
 */
void printInstructions();

/*
 * Assert value at given address.
 *
 * @param short address 
 * @param uint8_t value 
 * @return bool true if address has same value; otherwise, false
 */
bool assertmem(uint16_t address, uint8_t value);

/**
 * Return the value of the carry flag.
 */
uint8_t carry();

/**
 * Return the value of the zero flag.
 */
uint8_t zero();

/**
 * Return the value of the interrupt flag.
 */
uint8_t interrupt();

/**
 * Return the value of the decimal flag.
 */
uint8_t decimal();

/** 
 * Return the value of the break flag.
 */
uint8_t brk();

/**
 * Return the value of the overflow flag.
 */
uint8_t overflow();

/**
 * Return the value of the sign flag.
 */
uint8_t sign();

/**
 * Return the value of the accumulator.
 */
uint8_t a();  /// Accumulator

/**
 * Return the value of the X register.
 */
uint8_t x();  /// Index register X

/**
 * Return the value of the Y register.
 */
uint8_t y();  /// Index register Y

/**
 * Return the value of the program counter.
 */
uint16_t pc(); /// Program counter

/**
 * Return the value of the stack pointer.
 */
uint8_t sp(); /// Stack pointer

/**
 * Return the value of the status register.
 */
uint8_t p();  /// Status register

#endif



